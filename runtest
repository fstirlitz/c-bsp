#!/usr/bin/env python3
import sys
import codecs
import glob
import tempfile
import pathlib
import subprocess
import atexit
import argparse

sys.stdout = codecs.getwriter(sys.stdout.encoding)(sys.stdout.detach(), errors='surrogateescape')
sys.stderr = codecs.getwriter(sys.stderr.encoding)(sys.stderr.detach(), errors='surrogateescape')

def parse_args():
	parser = argparse.ArgumentParser()
	parser.add_argument('testfile', metavar='TEST_FILE', type=pathlib.Path)
	parser.add_argument('-r', '--replace', action='store_const', const=True)
	parser.add_argument('-v', '--verbose', action='store_const', const=True)
	parser.add_argument('-k', '--keep', action='store_const', const=True)
	parser.add_argument('--no-setrlimit', action='store_const', const=True)
	return parser.parse_args()

args = parse_args()

testfile = args.testfile.open('rt')

in_source    = []
in_data      = bytearray()
in_data_at   = 0
in_choices   = []
expect_msg   = []
expect_data  = in_data
expect_fatal = False
expect_exit  = 0
test_dis     = True

mode = 'source'
for line in testfile:
	if line.startswith(';;;#'):
		continue
	if line.startswith(';;;;'):
		line = line[len(';;;;'):].strip()
		sect, _, param = line.partition(' ')

		if sect == 'source':
			mode = 'source'
		elif sect == 'output':
			mode = 'output'
		elif sect == 'data':
			mode = 'data'
		elif sect == 'data-at':
			in_data_at = int(param.strip(), 0)
		elif sect == 'target':
			mode = 'target'
			if expect_data is in_data:
				expect_data = bytearray()
		elif sect == 'comment':
			mode = 'comment'
		elif sect == 'choose':
			in_choices.append(int(param.strip(), 0))
		elif sect == 'fatal':
			expect_fatal = True
		elif sect == 'skipdis':
			test_dis = False
		elif sect == 'exit':
			expect_exit = int(param.strip(), 0)
		else:
			print("=== Invalid section: {} ===".format(repr(line)))
			sys.exit(1)
		continue

	if mode == 'comment':
		continue
	elif mode == 'source':
		in_source.append(line)
	elif mode == 'output':
		expect_msg.append(line)
	elif mode == 'data':
		in_data += bytes.fromhex(line.strip())
	elif mode == 'target':
		expect_data += bytes.fromhex(line.strip())
	else:
		print("=== No mode ===")
		sys.exit(1)

if expect_msg is not None:
	expect_msg = ''.join(expect_msg)

in_source = ''.join(in_source).encode('utf-8')

fname_tmpdir = pathlib.Path(tempfile.mkdtemp(prefix='bsptest-'))
fname_bsp0   = fname_tmpdir / 'bsp0'
fname_input  = fname_tmpdir / 'input'
fname_target = fname_tmpdir / 'output'
fname_dis    = fname_tmpdir / 'dis'
fname_bsp1   = fname_tmpdir / 'bsp1'

discrepancy = False

# compile
if args.verbose:
	print("=== Compiling ===")

compiler = subprocess.Popen(
	['bspcomp/bspcomp', '/dev/stdin', str(fname_bsp0)],
	stdin=subprocess.PIPE
)
compiler.stdin.write(in_source)
compiler.stdin.close()
if compiler.wait() != 0:
	print("=== Compilation error ===")
	sys.exit(1)

if test_dis:
	if args.verbose:
		print("=== Disassembling ===")

	disassembler = subprocess.Popen(
		['./bspdis', '-n', '-o', str(fname_dis), str(fname_bsp0)],
		stdout=subprocess.PIPE, stderr=subprocess.PIPE
	)
	(_, dis_err) = disassembler.communicate()
	if args.verbose and dis_err:
		print("=== Disassembler error ===")
		print(dis_err.decode('utf-8', 'surrogateescape'))

	if args.verbose:
		print("=== Disassembly ===")
		with fname_dis.open('r', errors='surrogateescape') as dis:
			print(dis.read())
		print("=== Compiling again ===")

	compiler = subprocess.Popen(
		['bspcomp/bspcomp', str(fname_dis), str(fname_bsp1)]
	)
	if compiler.wait() != 0:
		print("=== Second-pass compilation error ===")
		discrepancy = True
	else:
		if args.verbose:
			print("=== Verifying ===")

		with fname_bsp0.open('rb') as bsp0:
			with fname_bsp1.open('rb') as bsp1:
				data0 = bsp0.read()
				data1 = bsp1.read()
				if data0 != data1:
					print("=== Disassembly verification failed ===")
					print("first : {}".format(data0))
					print("second: {}".format(data1))
					discrepancy = True

# prepare input
with fname_input.open('wb') as f:
	f.seek(in_data_at)
	if in_data:
		f.write(in_data)
	else:
		f.truncate()

if args.verbose:
	print("=== Running ===")

import resource

def set_limits():
	as_limit = 64 * 1024 * 1024
	resource.setrlimit(resource.RLIMIT_AS, (as_limit, as_limit))

interpreter = subprocess.Popen(
	['./bsp', '-N16', '-I8192', '-dttk' if args.verbose else '-k', str(fname_bsp0), str(fname_input), str(fname_target)],
	stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, preexec_fn=None if args.no_setrlimit else set_limits
)

(actual_msg, actual_err) = interpreter.communicate(
	input=(''.join('{}\n'.format(ch) for ch in in_choices) + 'q\n').encode('ascii'))

actual_msg = actual_msg.decode('utf-8')
if actual_msg and not actual_msg.endswith('\n'):
	actual_msg += '\n'
actual_exit = interpreter.returncode
actual_fatal = (actual_exit == 255)

try:
	with fname_target.open('rb') as f:
		f.seek(in_data_at)
		actual_data = f.read()
except FileNotFoundError:
	actual_data = None

def rm_rf(node):
	if node.is_dir():
		for child in node.iterdir():
			rm_rf(child)
		node.rmdir()
	else:
		node.unlink()

if args.keep:
	print("=== Files kept in {} ===".format(fname_tmpdir))
else:
	rm_rf(fname_tmpdir)

if expect_fatal:
	if not actual_fatal:
		discrepancy = True
elif expect_exit != actual_exit:
	discrepancy = True
if expect_msg != actual_msg:
	discrepancy = True
if actual_data is not None and expect_data != actual_data:
	discrepancy = True

if discrepancy or args.verbose:
	print("=== Standard error ===")
	print(actual_err.decode('utf-8', 'surrogateescape'))

	if expect_msg is not None:
		print("=== Expected output ===")
		print(expect_msg)
	else:
		print("=== (No expected output) ===")
	if expect_msg != actual_msg:
		print("=== Actual output ===")
		print(actual_msg)

	print("=== Expected final data ===")
	print(expect_data.hex())
	if expect_data != actual_data and actual_data is not None:
		print("=== Actual final data ===")
		print(actual_data.hex())

	if not expect_fatal:
		print("=== Expected exit code: {} ===".format(expect_exit))
		if actual_fatal:
			print("=== Unexpected fatal error ===")
		elif expect_exit != actual_exit:
			print("=== Actual exit code: {} ===".format(actual_exit))
	else:
		if not actual_fatal:
			print("=== Expected fatal error did not happen ===")

_OUTPUT_SECTIONS = frozenset(('output', 'target', 'exit', 'fatal'))

if discrepancy:
	if args.replace:
		import os
		newname = args.testfile.with_suffix('.newtest')
		with args.testfile.open('rt') as testfile, newname.open('wt') as newfile:
			skip = False
			for line in testfile:
				if line.startswith(';;;;'):
					sect, _, param = line[len(';;;;'):].strip().partition(' ')
					skip = sect in _OUTPUT_SECTIONS
				if not skip:
					newfile.write(line)
			if actual_msg:
				newfile.write(';;;; output\n')
				newfile.write(actual_msg)
			if actual_data != in_data:
				newfile.write(';;;; target\n')
				newfile.write(actual_data.hex() + '\n')
			if actual_fatal:
				newfile.write(';;;; fatal\n')
			elif actual_exit:
				newfile.write(';;;; exit %u\n' % (actual_exit))
		newname.replace(args.testfile)

	sys.exit(1)
